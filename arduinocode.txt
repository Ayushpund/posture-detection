#include <Wire.h>
#include <WiFi.h>
#include <HTTPClient.h>

const char* WIFI_SSID = "YOUR_WIFI_SSID";
const char* WIFI_PASS = "YOUR_WIFI_PASSWORD";
const char* FIREBASE_URL = "https://your-project.firebaseio.com/";
const char* FIREBASE_AUTH = "YOUR_DATABASE_SECRET_OR_AUTH";

const uint8_t MPU_ADDR = 0x68;

const int FLEX_ADC_PIN = 34;
const int ACTUATOR_PIN = 18;
const int LED_PIN = 2;

const float DT = 0.02f;
const float ALPHA = 0.98f;
const float GYRO_SCALE = 131.0f;
const float ACCEL_SCALE = 16384.0f;

float POSTURE_THRESHOLD_DEG = 15.0f;
float HYSTERESIS_DEG = 4.0f;
unsigned long BAD_POSTURE_MIN_MS = 1500;

bool USE_DEEP_SLEEP = false;
uint64_t SLEEP_DURATION_US = 5 * 1000000ULL;

float pitch = 0.0f;
float gyroPitch = 0.0f;
unsigned long badStartTime = 0;
bool isAlerting = false;

bool FAULT_INJECT_RAPID_MOVE = false;
bool FAULT_INJECT_PROLONGED_SLOUCH = false;

void setupMPU();
void readMPUraw(float &accX, float &accY, float &accZ, float &gyroX, float &gyroY, float &gyroZ);
float accelToPitchDeg(float ax, float ay, float az);
void uploadToFirebase(float pitchVal, float flexVal, bool badPosture);
void triggerActuator(bool on);
float readFlexNormalized();
void doFaultInjectionIfNeeded();
void goToDeepSleepIfConfigured();

void setup() {
  Serial.begin(115200);
  delay(200);
  pinMode(ACTUATOR_PIN, OUTPUT);
  digitalWrite(ACTUATOR_PIN, LOW);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  Wire.begin();
  setupMPU();

  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);

  Serial.print("Connecting to WiFi");
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - start < 8000) {
    delay(200);
    Serial.print(".");
  }
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi connected.");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nWiFi not connected (will retry later).");
  }
}

void loop() {
  unsigned long loopStart = millis();
  const int samplesPerWindow = 5;
  float pitchSum = 0.0f;
  float flexSum = 0.0f;

  for (int i = 0; i < samplesPerWindow; ++i) {
    float ax, ay, az, gx, gy, gz;
    readMPUraw(ax, ay, az, gx, gy, gz);

    float gyroY_deg = gy / GYRO_SCALE;
    gyroPitch += gyroY_deg * DT;
    float accelPitch = accelToPitchDeg(ax, ay, az);
    pitch = ALPHA * (pitch + gyroY_deg * DT) + (1.0f - ALPHA) * accelPitch;
    float flex = readFlexNormalized();

    pitchSum += pitch;
    flexSum += flex;

    delay((int)(DT * 1000.0f));
  }

  float pitchAvg = pitchSum / samplesPerWindow;
  float flexAvg = flexSum / samplesPerWindow;

  doFaultInjectionIfNeeded();

  static bool wasBad = false;
  bool nowBad = false;
  if (!wasBad) {
    if (abs(pitchAvg) > POSTURE_THRESHOLD_DEG) {
      nowBad = true;
      badStartTime = (badStartTime == 0) ? millis() : badStartTime;
    }
  } else {
    if (abs(pitchAvg) > (POSTURE_THRESHOLD_DEG - HYSTERESIS_DEG)) {
      nowBad = true;
    }
  }

  if (nowBad) {
    if (millis() - badStartTime >= BAD_POSTURE_MIN_MS) {
      isAlerting = true;
    } else {
      isAlerting = false;
    }
  } else {
    badStartTime = 0;
    isAlerting = false;
  }

  if (isAlerting) {
    triggerActuator(true);
    digitalWrite(LED_PIN, HIGH);
  } else {
    triggerActuator(false);
    digitalWrite(LED_PIN, LOW);
  }

  Serial.printf("Pitch: %.2f deg | Flex: %.3f | Bad: %s | Alerting: %s\n",
                pitchAvg, flexAvg, nowBad ? "YES" : "NO", isAlerting ? "YES" : "NO");

  if (WiFi.status() == WL_CONNECTED) {
    uploadToFirebase(pitchAvg, flexAvg, isAlerting);
  }

  goToDeepSleepIfConfigured();

  unsigned long loopElapsed = millis() - loopStart;
  const unsigned long idleMs = 200;
  if (!USE_DEEP_SLEEP) delay(max(0L, (long)idleMs - (long)loopElapsed));
}

void setupMPU() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6B);
  Wire.write(0x00);
  Wire.endTransmission();
  delay(50);

  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x1B);
  Wire.write(0x00);
  Wire.endTransmission();

  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x1C);
  Wire.write(0x00);
  Wire.endTransmission();
}

void readMPUraw(float &accX, float &accY, float &accZ, float &gyroX, float &gyroY, float &gyroZ) {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDR, (uint8_t)14);

  while (Wire.available() < 14) { }

  int16_t ax = (Wire.read() << 8) | Wire.read();
  int16_t ay = (Wire.read() << 8) | Wire.read();
  int16_t az = (Wire.read() << 8) | Wire.read();
  int16_t temp = (Wire.read() << 8) | Wire.read();
  int16_t gx = (Wire.read() << 8) | Wire.read();
  int16_t gy = (Wire.read() << 8) | Wire.read();
  int16_t gz = (Wire.read() << 8) | Wire.read();

  accX = (float)ax / ACCEL_SCALE;
  accY = (float)ay / ACCEL_SCALE;
  accZ = (float)az / ACCEL_SCALE;

  gyroX = (float)gx;
  gyroY = (float)gy;
  gyroZ = (float)gz;
}

float accelToPitchDeg(float ax, float ay, float az) {
  float pitchRad = atan2(-ax, sqrt(ay * ay + az * az));
  float pitchDeg = pitchRad * 57.29577951308232f;
  return pitchDeg;
}

float readFlexNormalized() {
  int raw = analogRead(FLEX_ADC_PIN);
  const int minADC = 1000;
  const int maxADC = 3000;
  int clipped = constrain(raw, minADC, maxADC);
  float norm = (float)(clipped - minADC) / (float)(maxADC - minADC);
  return norm;
}

void triggerActuator(bool on) {
  digitalWrite(ACTUATOR_PIN, on ? HIGH : LOW);
}

void uploadToFirebase(float pitchVal, float flexVal, bool badPosture) {
  if (WiFi.status() != WL_CONNECTED) return;

  HTTPClient http;
  String url = String(FIREBASE_URL) + "posture_logs.json";
  if (strlen(FIREBASE_AUTH) > 0) {
    url += "?auth=" + String(FIREBASE_AUTH);
  }

  String payload = "{";
  payload += "\"timestamp\": " + String((unsigned long) (millis() / 1000));
  payload += ", \"pitch\": " + String(pitchVal, 2);
  payload += ", \"flex\": " + String(flexVal, 3);
  payload += ", \"bad\": " + String(badPosture ? "true" : "false");
  payload += "}";

  http.begin(url);
  http.addHeader("Content-Type", "application/json");
  int httpCode = http.POST(payload);
  http.end();
}

void doFaultInjectionIfNeeded() {
  if (FAULT_INJECT_RAPID_MOVE) {
    pitch += 30.0f;
    FAULT_INJECT_RAPID_MOVE = false;
    Serial.println("[FAULT] Rapid move injected.");
  }
  if (FAULT_INJECT_PROLONGED_SLOUCH) {
    pitch += 20.0f;
    Serial.println("[FAULT] Prolonged slouch injection active.");
  }
}

void goToDeepSleepIfConfigured() {
  if (!USE_DEEP_SLEEP) return;
  Serial.printf("Entering deep sleep for %llu us\n", SLEEP_DURATION_US);
  Serial.flush();
  esp_sleep_enable_timer_wakeup(SLEEP_DURATION_US);
  esp_deep_sleep_start();
}
